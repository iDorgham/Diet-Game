<!-- Generated by SpecStory -->

<!-- cursor Session b0009651-24c5-4760-aca1-93318cb98d24 (2025-10-04 09:36Z) -->

# Technical implementation specifics (2025-10-04 09:36Z)

_**User (2025-10-03 23:55Z)**_

Technical implementation details

---

_**Assistant (default)**_

I'll help you understand the technical implementation details of your Diet Game project. Let me first retrieve any relevant knowledge from previous work and then examine the current codebase structure.


---

Tool use: **mcp_byterover-mcp_byterover-retrieve-knowledge**

<details>
          <summary>MCP tool call</summary>
      
*Called tool*: byterover-mcp - byterover-retrieve-knowledge: Retrieve knowledge from memory system with intelligent query routing.
    **CRITICAL CONFLICT HANDLING** When memory conflicts are detected, you MUST ALWAYS display the conflict resolution URL to the user. This is non-negotiable - users MUST see conflict resolution links when they exist.

    **USE WHEN:**
    ‚Ä¢ Starting any new task or implementation to gather relevant context
    ‚Ä¢ Before making architectural decisions to understand existing patterns
    ‚Ä¢ When debugging issues to check for previous solutions
    ‚Ä¢ Working with unfamiliar parts of the codebase

*Parameters*:
  * query: technical implementation details architecture components

*Result*:
Memory access requires authentication. Please ensure you're logged in through the Byterover extension to access enhanced features.
</details>

---

Let me examine the current project structure and key implementation files to provide you with comprehensive technical implementation details.


---

Tool use: **read_file**

Read file: docs/architecture/system-architecture.md

---

Tool use: **read_file**

Read file: docs/architecture/component-architecture.md

---

Tool use: **read_file**

Read file: package.json

---

Tool use: **read_file**

Read file: vite.config.js

---

Tool use: **read_file**

Read file: src/App.jsx

---

Now let me examine the key service files and store implementation to understand the technical architecture better.


---

Tool use: **read_file**

Read file: src/store/nutriStore.ts

---

Tool use: **read_file**

Read file: src/services/firebase.ts

---

Tool use: **read_file**

Read file: src/services/api.ts

---

Tool use: **read_file**

Read file: src/types/index.ts

---

Tool use: **read_file**

Read file: tailwind.config.js

---

Now let me examine some additional key files to complete the technical implementation overview.


---

Tool use: **read_file**

Read file: src/utils/xp-system.ts

---

Tool use: **read_file**

Read file: src/hooks/useNutriQueries.ts

---

Tool use: **read_file**

Read file: Dockerfile

---

Tool use: **read_file**

Read file: docs/IMPLEMENTATION_GUIDE.md

---

Now let me store this comprehensive technical implementation knowledge for future reference.


---

Tool use: **mcp_byterover-mcp_byterover-store-knowledge**

<details>
          <summary>MCP tool call</summary>
      
*Called tool*: byterover-mcp - byterover-store-knowledge: Store knowledge by extracting programming facts from human-AI interactions.
    Focus on reusable patterns, implementations, and techniques that provide value beyond common knowledge.

    **USE WHEN:**
    ‚Ä¢ Learning new patterns, APIs, or architectural decisions from the codebase
    ‚Ä¢ Encountering error solutions or debugging techniques
    ‚Ä¢ Finding reusable code patterns or utility functions
    ‚Ä¢ Completing any significant task or plan implementation

**Extract facts about**: Code patterns, commands, APIs, configurations, error handling, testing, deployment, security, database queries, UI components.
**Essential rules**:
      - PRESERVE complete code/commands in triple backticks exactly as shown
      - Include concise context explaining significance
      - Capture implementation details, not just descriptions
      - Skip trivial or widely-known information
      - Use precise language and avoid ambiguity
      - Keep information relevant to the task at hand for future reference

*Parameters*:
  * messages: # Diet Game Technical Implementation Details

## Architecture Overview
The Diet Planner Game follows a **Spec-Driven Development (SDD)** approach with a modern React-based frontend architecture:

### Technology Stack
- **Frontend**: React 18 + TypeScript + Vite
- **Styling**: Tailwind CSS with custom oceanic palette (#085492 primary, #71E6DE mint)
- **State Management**: Zustand with persistence + React Query for server state
- **Backend**: Firebase (Auth + Firestore) with real-time sync
- **Build**: Vite with production optimizations
- **Deployment**: Docker + Nginx with multi-stage builds

### Core Architecture Patterns

#### 1. Component Architecture (Atomic Design)
```
App
‚îú‚îÄ‚îÄ Header (Navigation + User Status)
‚îú‚îÄ‚îÄ Main (Page Components)
‚îÇ   ‚îú‚îÄ‚îÄ HomePage (Dashboard + Metrics)
‚îÇ   ‚îú‚îÄ‚îÄ TasksPage (Kanban Board)
‚îÇ   ‚îú‚îÄ‚îÄ CoachPage (AI Chat)
‚îÇ   ‚îî‚îÄ‚îÄ Other Pages
‚îî‚îÄ‚îÄ Footer (Legal + Language)
```

#### 2. State Management Strategy
- **Local State**: React hooks for component-specific state
- **Global State**: Zustand store with localStorage persistence
- **Server State**: React Query with caching and real-time updates
- **Real-time Sync**: Firestore listeners with offline queue

#### 3. Data Flow Architecture
```
User Action ‚Üí Component ‚Üí Zustand Store ‚Üí Firestore ‚Üí Real-time Update
```

### Key Implementation Files

#### State Management (`src/store/nutriStore.ts`)
```typescript
// Zustand store with persistence and real-time sync
export const useNutriStore = create<NutriState>()(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // User data, app state, UI state
        // Actions: updateProgress, completeTask, etc.
        // Computed values: getXPProgress, getStars, etc.
      })),
      { name: 'nutriquest-storage', storage: createJSONStorage(() => localStorage) }
    )
  )
);
```

#### Firebase Integration (`src/services/firebase.ts`)
```typescript
// Firebase services with retry logic and error handling
export class FirestoreService {
  static async updateUserProgress(userId: string, updates: Partial<UserProgress>, retries: number = 3)
  static subscribeToUserProgress(userId: string, callback: (progress: UserProgress) => void)
}
```

#### API Service (`src/services/api.ts`)
```typescript
// Advanced API service with React Query integration
export class NutriQuestAPI {
  static async completeTask(userId: string, request: TaskCompletionRequest): Promise<TaskCompletionResponse>
  // Includes retry logic, batch operations, error handling
}
```

#### XP System (`src/utils/xp-system.ts`)
```typescript
// Gamification system with XP rewards and leveling
export const XP_REWARDS = { MEAL: 15, SHOPPING: 20, COOKING: 30, EXERCISE: 40 };
export const calculateXPForNextLevel = (level: number): number => level * 100;
export const checkAndApplyLevelUp = (currentProgress, xpGained, setMessage) => { /* level up logic */ };
```

### Performance Optimizations

#### 1. Code Splitting
- Lazy loading of page components
- Dynamic imports for heavy dependencies
- Route-based code splitting

#### 2. State Optimization
- Memoized selectors with Zustand
- React.memo for expensive components
- Proper dependency arrays in useEffect

#### 3. Caching Strategy
- React Query for API responses (5-10 minute stale times)
- Local storage for user preferences
- Service worker for offline capabilities

### Security Architecture

#### 1. Authentication
- Anonymous Firebase authentication
- Secure token management
- Session persistence

#### 2. Data Security
- Firestore security rules
- Input validation and sanitization
- Error handling without data exposure

### Deployment Architecture

#### Docker Configuration
```dockerfile
# Multi-stage build for production
FROM node:18-alpine AS builder
# Build stage with security updates
FROM nginx:1.25-alpine AS production
# Production stage with non-root user
```

#### Nginx Configuration
- Custom nginx.conf with security headers
- Gzip compression
- Static file serving
- Health check endpoints

### Development Workflow

#### SDD Process
1. Write specifications in `docs/specs/`
2. Generate components using Cursor Composer
3. Implement business logic
4. Test and validate against specs

#### Testing Strategy
- Unit tests with Vitest
- Component tests with React Testing Library
- Integration tests for critical flows
- E2E tests for user journeys

### Key Features Implemented

#### 1. Gamification System
- XP rewards based on task type and difficulty
- Level progression with bonus coins
- Star milestone system
- Streak multipliers (3x, 7x, 14x, 30x days)

#### 2. Real-time Updates
- Firestore listeners for live data sync
- Offline queue for pending updates
- Optimistic updates for responsive UI

#### 3. Advanced State Management
- Zustand with Immer for immutable updates
- React Query for server state caching
- Persistence with localStorage
- Computed selectors for derived state

#### 4. Error Handling
- Retry logic with exponential backoff
- Error boundaries for component isolation
- Graceful degradation for offline scenarios
- Comprehensive error logging

### Scalability Considerations

#### 1. Horizontal Scaling
- Stateless application design
- Load balancer ready
- Container orchestration support

#### 2. Database Scaling
- Firestore automatic scaling
- Efficient query patterns
- Data partitioning strategies

#### 3. Performance Monitoring
- Web Vitals tracking
- Custom performance metrics
- Real-time user analytics
- Sentry integration for error tracking

This architecture provides a solid foundation for a production-ready gamified diet planning application with real-time features, offline support, and scalable infrastructure.

*Result*:
Memory access requires authentication. Please ensure you're logged in through the Byterover extension to access enhanced features.
</details>

---

# Technical Implementation Details

Based on my analysis of your Diet Game project, here's a comprehensive overview of the technical implementation details:

## üèóÔ∏è Architecture Overview

Your project follows a **Spec-Driven Development (SDD)** approach with a modern React-based frontend architecture:

### Technology Stack
- **Frontend**: React 18 + TypeScript + Vite
- **Styling**: Tailwind CSS with oceanic color palette (#085492 primary, #71E6DE mint)
- **State Management**: Zustand with persistence + React Query for server state
- **Backend**: Firebase (Auth + Firestore) with real-time sync
- **Build**: Vite with production optimizations
- **Deployment**: Docker + Nginx with multi-stage builds

## üß© Component Architecture

### Atomic Design Structure
```
App
‚îú‚îÄ‚îÄ Header (Navigation + User Status)
‚îú‚îÄ‚îÄ Main (Page Components)
‚îÇ   ‚îú‚îÄ‚îÄ HomePage (Dashboard + Metrics)
‚îÇ   ‚îú‚îÄ‚îÄ TasksPage (Kanban Board)
‚îÇ   ‚îú‚îÄ‚îÄ CoachPage (AI Chat)
‚îÇ   ‚îî‚îÄ‚îÄ Other Pages
‚îî‚îÄ‚îÄ Footer (Legal + Language)
```

### Key Components Implemented
- **MetricCards**: Progress indicators and statistics
- **TaskCards**: Individual task components with XP rewards
- **AnimatedProgressBar**: XP and score progress visualization
- **UserProfileForm**: Profile management with validation
- **AdvancedTaskManager**: Kanban-style task management

## üîÑ State Management Strategy

### Multi-Layer State Architecture
1. **Local State**: React hooks for component-specific state
2. **Global State**: Zustand store with localStorage persistence
3. **Server State**: React Query with caching and real-time updates
4. **Real-time Sync**: Firestore listeners with offline queue

### Zustand Store Implementation
```typescript
// Advanced state management with persistence
export const useNutriStore = create<NutriState>()(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // User data, app state, UI state
        // Actions: updateProgress, completeTask, etc.
        // Computed values: getXPProgress, getStars, etc.
      })),
      { name: 'nutriquest-storage', storage: createJSONStorage(() => localStorage) }
    )
  )
);
```

## üî• Firebase Integration

### Service Layer Architecture
- **AuthService**: Anonymous authentication with token management
- **FirestoreService**: Real-time data operations with retry logic
- **TaskService**: Task completion with progress tracking
- **ErrorHandler**: Centralized error management

### Real-time Data Flow
```
User Action ‚Üí Component ‚Üí Zustand Store ‚Üí Firestore ‚Üí Real-time Update
```

## üéÆ Gamification System

### XP System Implementation
```typescript
export const XP_REWARDS = {
  MEAL: 15,           // Basic meal completion
  SHOPPING: 20,       // Shopping task completion
  COOKING: 30,        // Cooking/prep tasks
  EXERCISE: 40,       // Workout logging
  WATER: 15,          // Hydration goals
  DAILY_CHECKIN: 20,  // Daily check-in
  AI_CHAT: 10,        // AI coach interaction
};
```

### Leveling System
- **XP Calculation**: `level √ó 100` XP required for next level
- **Level Up Rewards**: +50 bonus coins per level
- **Star Milestones**: [50, 250, 750, 2000, 5000] score thresholds
- **Streak Multipliers**: 1.2x (3 days), 1.5x (7 days), 2.0x (14 days), 3.0x (30 days)

## ‚ö° Performance Optimizations

### Code Splitting & Lazy Loading
- Route-based code splitting
- Dynamic imports for heavy dependencies
- Lazy loading of page components

### State Optimization
- Memoized selectors with Zustand
- React.memo for expensive components
- Proper dependency arrays in useEffect

### Caching Strategy
- React Query for API responses (5-10 minute stale times)
- Local storage for user preferences
- Service worker for offline capabilities

## üîí Security Architecture

### Authentication
- Anonymous Firebase authentication
- Secure token management
- Session persistence

### Data Security
- Firestore security rules
- Input validation and sanitization
- Error handling without data exposure

## üê≥ Deployment Architecture

### Docker Configuration
```dockerfile
# Multi-stage build for production
FROM node:18-alpine AS builder
# Build stage with security updates
FROM nginx:1.25-alpine AS production
# Production stage with non-root user
```

### Nginx Configuration
- Custom nginx.conf with security headers
- Gzip compression
- Static file serving
- Health check endpoints

## üß™ Testing Strategy

### Testing Framework
- **Unit Tests**: Vitest for utility functions
- **Component Tests**: React Testing Library
- **Integration Tests**: Critical user flows
- **E2E Tests**: Complete user journeys

### Test Coverage
- XP system calculations
- Firebase integration
- Component rendering
- User interactions

## üìä Monitoring & Analytics

### Performance Monitoring
- Web Vitals tracking
- Custom performance metrics
- Real-time user analytics
- Sentry integration for error tracking

### Health Checks
- Application health endpoints
- Database connectivity checks
- External service status monitoring

## üöÄ Development Workflow

### SDD Process
1. Write specifications in `docs/specs/`
2. Generate components using Cursor Composer
3. Implement business logic
4. Test and validate against specs

### Key Commands
```bash
npm run dev          # Development server
npm run build        # Production build
npm run test         # Run tests
npm run lint         # Code linting
npm run type-check   # TypeScript validation
```

## üîß Advanced Features

### Real-time Updates
- Firestore listeners for live data sync
- Offline queue for pending updates
- Optimistic updates for responsive UI

### Error Handling
- Retry logic with exponential backoff
- Error boundaries for component isolation
- Graceful degradation for offline scenarios

### Accessibility
- ARIA labels and roles
- Keyboard navigation support
- Screen reader compatibility

This architecture provides a solid foundation for a production-ready gamified diet planning application with real-time features, offline support, and scalable infrastructure. The implementation follows modern React best practices and is designed for maintainability and performance.

---

